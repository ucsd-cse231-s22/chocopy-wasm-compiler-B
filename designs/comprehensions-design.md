# Comprehensions Design Document

---

## Week 10 Update -- MS2 New Features

__*TL;DR*__

We now support
```python
# TRUE set comprehension
s:set[int] = None
s = {<expr> for <itme> in <iterable> if <if_cond>}

# FAKE list/generator comprehension -- need print to visualize
(print(<expr>) for <itme> in <iterable> if <if_cond>) # or use []
```
where `<iterable>` can be `list`, `set`, or any iterable class with `next()` and `hasnext()`.

---


As outlined in the week 8 update, we originally planned to:
* Support storing values generated by comprehensions into the corresponding data structure
* Support list, set, dictionary, and string as the iterable object in a comprehension expression
* Support destructuring and bignums

However, some of the above features were not implemented in MS2 because of dependency reasons:
* We couldn't construct a list from a list comprehension, because `list` type is currently designed to be a static data structure and we couldn't append new elements to a list dynamically
* We couldn't support `dictionary` and `string` as the iterable object -- they are either not implemented or not merged by other groups
* We couldn't support destructuring assignment because it would require changes to many parts of our existing code (from `ast.ts` to `lower.ts`) and because of the time constraint. We couldn't support bignums because it is not merged yet.

Our new features are:
* __`list` as the iterable object__
  
  ```python
  # print 1, 2, 3, 4, 5
  (print(num) for num in [1, 2, 3, 4, 5])

  # print True, False, True
  (print(b) for b in [True, False, True])
  ```

  Because `list` group didn't implement `next()` and `hasnext()`, so we created a built-in class `ListIterable` that implements these two methods (see the detailed implementation in `comp.test.ts`). Upon receiving a list as the iterable object, we would create a `ListIterable` object using the list and its length, and traverse the list with this new iterable.

* __`set` as the iterable object__
  
  ```python
  # print 1, 2, 3, 4, 5
  (print(num) for num in {1, 2, 3, 4, 5})

  # print False, True (the order depends on set implementation)
  (print(b) for b in [True, False])
  ```

  Thankfully, `set` group provided `set.firstItem()`, `set.next(key)`, and `set.hasnext(key)`. We were able to direcly use their API and traverse a set.
* __Set Comprehension__ (Yay!)
  
  ```python
  # print set 1, 2, 3, 4, 5
  s1:set[int] = None
  s1 = {num for num in [1, 2, 3, 4, 5]}
  print(s1)

  # print set 3, 7, 999
  # (it removes a duplicate 999!)
  s2:set[int] = None
  s2 = {num + 1 if num % 4 != 0 else 999 for num in {1, 2, 3, 4, 5, 6, 7, 8} if num % 2 == 0}
  print(s2)
  ```
  Set group provided `set.add()` method so we were able to dynamically add generated values to a set, and confidently delegate the task of removing duplicates to them.

---

## Week 8 Update -- Design for MS2

### What we've achieved so far
We now only support a limited syntax like this:
```python
(<expr> for <item> in Range().new(<start>, <end>, <step>) if <if_cond>)
# Can also use [] or {}
```
For example,
```python
(print(a if a > 0 else -a) for a in Range().new(-6, 6, 1) if a % 2 == 0)
```
prints `6, 4, 2, 0, 2, 4`.

Note that, at this point, the above comprehension expression does not actually construct a generator, but only evaluates the left-hand side expression (e.g. `print(...)`). Therefore, in order to visualize the values generated, we have to print them out.

### Features we plan to implement next
* We will figure out how we can store the values generated by comprehension expression into the actual data structures. As an example,
`[elem for elem in Range().new(0, 3, 1)]`
constructs a list `[0, 1, 2]`.
* We will add support to more iterable types rather than just a `Range` object. The following scenarios will be supported:

  ```python
  # list
  (elem for elem in [0, 1, 2])
  # set
  (elem for elem in {0, 1, 2})
  # dictionary
  (key for key in {1: 2, 3: 4})
  # string
  (ch for ch in "hello")
  ```
* We will work with Bignums and Destructuring Assignment group to achieve the following scenarios:

  ```python
  # range with bignums
  (num for num in Range().new(100000000000, 100000000005, 1))
  # destructure items in iterable object
  (a + b for a, b in [(1, 2), (3, 4)])
  ```

---

## Week 7 Update

We couldn't implement all features described in the design document submitted last week, but we do have some progress.

As is stated in the previous design document, comprehension expressions include list comprehension (```[]```), set/dictionary comprehension (```{}```), as well as generator comprehension (```()```). We mainly focused on generator comprehension this week, because other types of comprehension require the work of other groups.  

In terms of the iterable object, we only support 
```Range()``` objects for now. In milestone 2, with the work of other groups, we will also be able to handle other iterable objects, i.e. ```list```, ```set```, ```dictionary```, ```tuple```, ```generator```.

We added a ```Range``` class and a ```Generator``` class to ```repl.ts```. They both work, but are a little bit flawed. The ```Range``` and ```Generator``` classes share a same problem, that they can not properly stop iteration. We want any ```Range``` and ```Generator``` objects to stop returning items in the ```next()``` method, when the ```iterator``` comes to the end of the iterable object. However, we haven't implement this stop behavior in the ```next()``` method yet, but we checked it in the comprehension expression part. In addition, our generator comprehension cannot really act the way it should be ---- we can now only print out all items it will yield while calling ```next()```.

---
## Week 6 Contents
___

## Test Cases

Comprehensions follow this format:
```
<expr> for <name> in <iterable-expr> [if <expr>]?
```
A comprehension expression could be placed in a pair of square brackets ```[]``` (list comprehension), a pair of curly brackets ```{}``` (set/dictionary comprehension), or a pair of parentheses ```()``` (generator).

The expression before the ```for``` keyword could be any valid expression -- plain literals or free variables, unary/binary operations, function calls, class fields or method calls, or ternary expressions which we haven't implemented yet.

The iterable object after the ```in``` keyword could be of various type -- ```list```, ```set```, ```dictionary```, ```tuple```, ```generator```, or even another comprehension expression.

In addition, we can have an optional ```if``` condition to filter the items in the iterable object.

Therefore, there are so many scenarios to write test cases for. Since this is the first milestone and many cases are dependent on the implementation of other groups (specifically, list, for-loop/iterator, string, set/tuple/dictionary, and built-in library), __we plan to only support a range of integers as the iterable object by the end of week 7__. However, we are looking into possible ways to implement an ```Iterable``` interface that supports ```next()``` and ```has_next()``` to facilitate iterating over the above types.

---

### List Comprehensions

#### Test Case #1
```python
print([3 for _ in range(5)])
```
Should print ```[3, 3, 3, 3, 3]```

#### Test Case #2
```python
print([num * 2 for num in range(5)])
```
Should print ```[0, 2, 4, 6, 8]```

#### Test Case #3
```python
print([num * 2 if num % 2 == 0 else num * 3 for num in range(5)])
```
Should print ```[0, 3, 4, 9, 8]```

#### Test Case #4
```python
print([num for num in range(20) if num % 3 == 0])
```
Should print ```[0, 3, 6, 9, 12, 15, 18]```

---

### Set/Dictionary Comprehension

#### Test Case #5
```python
print({3 for _ in range(5)})
```
Should print ```{3}```

#### Test Case #6
```python
print({3 if val % 3 == 0 else (2 if val % 2 == 0 else 1) for val in range(8)})
```
Should print ```{1, 2, 3}``` (not necessarily sorted)

#### Test Case #7
```python
print({val : min(val, 6) for val in range(4, 8)})
```
Should print ```{4: 4, 5: 5, 6: 6, 7: 6}```

#### Test Case #8
```python
print({val // 2 : val for val in range(8)})
```
Should print ```{0: 1, 1: 3, 2: 5, 3: 7}```

---

### Generator

#### Test Case #9
```python
gen : generator = None
gen = (val for val in range(2, 8, 2))
print(next(gen))
```
Should print ```2```

#### Test Case #10
```python
gen : generator = None
x : int = 3
gen = (val + x for val in range(2, 8) if val < 5)
print(next(gen))
print(next(gen))
print(next(gen))
print(next(gen))
```
Should print
```python
5
6
7
StopIteration
```

---
---

## Changes to AST, Parser, and Type-checker

We think that comprehension expressions only require changes to the top-level AST -- they can be transformed to the current IR, so here we are only listing changes we intend to make to ```ast.ts```.

---

### AST

```ts
export type Expr<A> = ...
    // comprehension expression
    | { 
        a?: A, 
        tag: "comprehension", 
        type: Type, // type of comprehension - list/set/dict/generator
        lhs: Expr<A>, 
        item: string, 
        iterable: Expr<A>, 
        ifcond?: Expr<A> 
    }
    // ternary expression - in case people want to write this on lhs above
    | {
        a?: A, 
        tag: "ternary", 
        exprIfTrue: Expr<A>, 
        ifcond: Expr<A>, 
        exprIfFalse: Expr<A>
    }
```

```ts
export type Type = ... // assume other groups add list/set/tuple/dict/string here
    | { 
        tag: "generator", 
        type: Type // type of item generated each time calling next()
    }
```

```ts
export type Class<A> = ...
    | Iterable<A> // iterable interface

// we hope that list/set/tuple/dict/string will implement (i.e. inherit) this Iterable interface, and provide implementations of next() and has_next(), so that we may parse comprehension expressions to IR by calling them
export type Iterable<A> = 
    {
        a?: A,
        type: Type // type of iterable object
    }
```

---

### Parser/Type-checker

We the changes above, we plan to add new cases under ```traverseExpr()``` to parse comprehension/ternary expressions, and new cases under ```tcExpr()``` to type-check comprehension/ternary expressions.

---

### Range class

For the first milestone, since we want to support comprehensions with a range of integers, we may need to add a built-in class Range (like the one posted by Joe on Piazza) and implement its ```new()```, ```next()``` and ```has_next()``` to test our features.

---

Other than the changes mentioned above, we do not plan to add any other new datatypes or change the memory layout at this point.
